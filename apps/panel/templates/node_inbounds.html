{% extends "base.html" %}

{% block title %}Node Inbounds{% endblock %}

{% block content %}
<section>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
        <div>
            <h2>Manage Inbounds</h2>
            <small>Node: {{ node.name }} ({{ node.ip }})</small>
        </div>
        <a href="{{ admin_path }}/nodes" role="button" class="secondary outline">Back to Nodes</a>
    </div>

    <!-- Inbounds List -->
    <article>
        <h3>Active Inbounds</h3>
        <table role="grid">
            <thead>
                <tr>
                    <th>Tag</th>
                    <th>Protocol</th>
                    <th>Port</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for inbound in inbounds %}
                <tr>
                    <td>{{ inbound.tag }}</td>
                    <td><span class="badge secondary">{{ inbound.protocol|upper }}</span></td>
                    <td>{{ inbound.listen_port }}</td>
                    <td>
                        {% if inbound.enable %}
                        <span class="badge success">Enabled</span>
                        {% else %}
                        <span class="badge secondary">Disabled</span>
                        {% endif %}
                    </td>
                    <td>
                        <div role="group">
                            <button class="outline"
                                hx-get="{{ admin_path }}/nodes/{{ node.id }}/inbounds/{{ inbound.id }}"
                                hx-target="#edit-inbound-modal-content"
                                hx-on::after-request="document.getElementById('edit-inbound-modal').showModal()">
                                Edit
                            </button>
                            <button class="secondary outline" style="color: #ff5555; border-color: #ff5555;"
                                hx-delete="{{ admin_path }}/nodes/{{ node.id }}/inbounds/{{ inbound.id }}"
                                hx-confirm="Are you sure you want to delete this inbound?" hx-target="closest tr"
                                hx-swap="outerHTML">
                                Delete
                            </button>
                        </div>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        {% if inbounds.is_empty() %}
        <p style="text-align: center; color: #666; padding: 2rem;">No inbounds configured for this node.</p>
        {% endif %}
    </article>

    <!-- Edit Inbound Modal -->
    <dialog id="edit-inbound-modal">
        <article id="edit-inbound-modal-content" style="width: 800px; max-width: 90%;">
            <!-- Content loaded via HTMX -->
            <p aria-busy="true">Loading inbound details...</p>
        </article>
    </dialog>

    <!-- Add Inbound Form -->
    <article style="margin-top: 2rem;">
        <header>Add New Inbound</header>
        <form hx-post="{{ admin_path }}/nodes/{{ node.id }}/inbounds" hx-target="body" hx-swap="none">
            <div class="grid">
                <div>
                    <label for="tag">Tag (Unique Identifier)</label>
                    <input type="text" id="tag" name="tag" placeholder="vless-tcp-reality" required>
                </div>
                <div>
                    <label for="protocol">Protocol</label>
                    <select id="protocol" name="protocol" onchange="updateTemplates()" required>
                        <option value="vless">VLESS</option>
                        <option value="hysteria2">Hysteria 2</option>
                        <option value="trojan">Trojan</option>
                    </select>
                </div>
            </div>

            <div class="grid">
                <div>
                    <label for="listen_port">Listen Port</label>
                    <input type="number" id="listen_port" name="listen_port" value="443" required>
                </div>
                <div>
                    <label for="listen_ip">Listen IP</label>
                    <input type="text" id="listen_ip" name="listen_ip" value="::" required>
                    <div>
                        <label for="listen_ip">Listen IP</label>
                        <input type="text" id="listen_ip" name="listen_ip" value="::" required>
                    </div>
                </div>

                <!-- SNI Field (Helper) -->
                <div id="sni_container">
                    <label for="sni_input">Server Name (SNI) / Destination</label>
                    <input type="text" id="sni_input" placeholder="drive.google.com" oninput="updateSniFromJson()">
                    <small>Updates <code>server_name</code> or <code>dest</code> in Stream Settings.</small>
                </div>

                <label for="settings">Protocol Settings (JSON)</label>
                <textarea id="settings" name="settings" rows="6" style="font-family: monospace;">{}</textarea>
                <small>Specific settings for the selected protocol (e.g. clients, fallbacks).</small>

                <label for="stream_settings">Stream Settings (JSON)</label>
                <textarea id="stream_settings" name="stream_settings" rows="10" style="font-family: monospace;"
                    oninput="syncSniInput()">{}</textarea>
                <small>Transport layer settings (e.g. TCP, XTLS-Reality, QUIC).</small>

                <button type="submit" style="margin-top: 1rem;">Add Inbound</button>
        </form>
    </article>
</section>

<script>
    const templates = {
        vless: {
            settings: {
                "clients": [],
                "decryption": "none",
                "fallbacks": []
            },
            stream_settings: {
                "network": "tcp",
                "security": "reality",
                "reality_settings": {
                    "show": false,
                    "dest": "drive.google.com:443",
                    "xver": 0,
                    "server_names": ["drive.google.com"],
                    "private_key": "",
                    "short_ids": [""]
                }
            }
        },
        hysteria2: {
            settings: {
                "users": [],
                "up_mbps": 100,
                "down_mbps": 100,
                "ignore_client_bandwidth": false
            },
            stream_settings: {
                "network": "udp",
                "security": "tls",
                "tls_settings": {
                    "server_name": "drive.google.com",
                    "certificates": []
                }
            }
        },
        trojan: {
            settings: {
                "clients": [],
                "fallback": null
            },
            stream_settings: {
                "network": "tcp",
                "security": "tls",
                "tls_settings": {
                    "server_name": "drive.google.com",
                    "certificates": []
                }
            }
        }
    };

    function updateTemplates() {
        const protocol = document.getElementById('protocol').value;
        const tmpl = templates[protocol];
        if (tmpl) {
            document.getElementById('settings').value = JSON.stringify(tmpl.settings, null, 4);
            document.getElementById('stream_settings').value = JSON.stringify(tmpl.stream_settings, null, 4);

            // Auto-populate SNI input
            syncSniInput();
        }
    }

    function syncSniInput() {
        try {
            const json = JSON.parse(document.getElementById('stream_settings').value);
            let sni = "";

            // Check Reality
            if (json.reality_settings && json.reality_settings.server_names && json.reality_settings.server_names.length > 0) {
                sni = json.reality_settings.server_names[0];
            }
            // Check TLS
            else if (json.tls_settings && json.tls_settings.server_name) {
                sni = json.tls_settings.server_name;
            }

            if (sni) document.getElementById('sni_input').value = sni;
        } catch (e) { }
    }

    function updateSniFromJson() {
        const sni = document.getElementById('sni_input').value;
        try {
            const json = JSON.parse(document.getElementById('stream_settings').value);

            // Update Reality
            if (json.reality_settings) {
                json.reality_settings.server_names = [sni];
                // Also update dest if it looks like a domain
                if (json.reality_settings.dest && json.reality_settings.dest.includes(":")) {
                    json.reality_settings.dest = sni + ":443";
                }
            }
            // Update TLS
            else if (json.tls_settings) {
                json.tls_settings.server_name = sni;
            }
            // If neither, assumes TLS structure creation? No, stay safe.
            else {
                // Heuristic: if protocol is Hysteria2 or Trojan, assume TLS
                if (!json.tls_settings) json.tls_settings = {};
                json.tls_settings.server_name = sni;
            }

            document.getElementById('stream_settings').value = JSON.stringify(json, null, 4);
        } catch (e) { }
    }

    // Initialize
    updateTemplates();
</script>
{% endblock %}